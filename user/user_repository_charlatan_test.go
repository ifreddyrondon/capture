// generated by "charlatan Repository".  DO NOT EDIT.

package user

import "reflect"

// RepositorySaveInvocation represents a single call of FakeRepository.Save
type RepositorySaveInvocation struct {
	Parameters struct {
		Ident1 *User
	}
	Results struct {
		Ident2 error
	}
}

// NewRepositorySaveInvocation creates a new instance of RepositorySaveInvocation
func NewRepositorySaveInvocation(ident1 *User, ident2 error) *RepositorySaveInvocation {
	invocation := new(RepositorySaveInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// RepositoryGetInvocation represents a single call of FakeRepository.Get
type RepositoryGetInvocation struct {
	Parameters struct {
		Ident1 string
	}
	Results struct {
		Ident2 *User
		Ident3 error
	}
}

// NewRepositoryGetInvocation creates a new instance of RepositoryGetInvocation
func NewRepositoryGetInvocation(ident1 string, ident2 *User, ident3 error) *RepositoryGetInvocation {
	invocation := new(RepositoryGetInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return invocation
}

// RepositoryTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type RepositoryTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeRepository is a mock implementation of Repository for testing.
Use it in your tests as in this example:

	package example

	func TestWithRepository(t *testing.T) {
		f := &user.FakeRepository{
			SaveHook: func(ident1 *User) (ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeSave ...
		f.AssertSaveCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeSave.
*/
type FakeRepository struct {
	SaveHook func(*User) error
	GetHook  func(string) (*User, error)

	SaveCalls []*RepositorySaveInvocation
	GetCalls  []*RepositoryGetInvocation
}

// NewFakeRepositoryDefaultPanic returns an instance of FakeRepository with all hooks configured to panic
func NewFakeRepositoryDefaultPanic() *FakeRepository {
	return &FakeRepository{
		SaveHook: func(*User) (ident2 error) {
			panic("Unexpected call to Repository.Save")
		},
		GetHook: func(string) (ident2 *User, ident3 error) {
			panic("Unexpected call to Repository.Get")
		},
	}
}

// NewFakeRepositoryDefaultFatal returns an instance of FakeRepository with all hooks configured to call t.Fatal
func NewFakeRepositoryDefaultFatal(t_sym1 RepositoryTestingT) *FakeRepository {
	return &FakeRepository{
		SaveHook: func(*User) (ident2 error) {
			t_sym1.Fatal("Unexpected call to Repository.Save")
			return
		},
		GetHook: func(string) (ident2 *User, ident3 error) {
			t_sym1.Fatal("Unexpected call to Repository.Get")
			return
		},
	}
}

// NewFakeRepositoryDefaultError returns an instance of FakeRepository with all hooks configured to call t.Error
func NewFakeRepositoryDefaultError(t_sym2 RepositoryTestingT) *FakeRepository {
	return &FakeRepository{
		SaveHook: func(*User) (ident2 error) {
			t_sym2.Error("Unexpected call to Repository.Save")
			return
		},
		GetHook: func(string) (ident2 *User, ident3 error) {
			t_sym2.Error("Unexpected call to Repository.Get")
			return
		},
	}
}

func (f *FakeRepository) Reset() {
	f.SaveCalls = []*RepositorySaveInvocation{}
	f.GetCalls = []*RepositoryGetInvocation{}
}

func (f_sym3 *FakeRepository) Save(ident1 *User) (ident2 error) {
	if f_sym3.SaveHook == nil {
		panic("Repository.Save() called but FakeRepository.SaveHook is nil")
	}

	invocation_sym3 := new(RepositorySaveInvocation)
	f_sym3.SaveCalls = append(f_sym3.SaveCalls, invocation_sym3)

	invocation_sym3.Parameters.Ident1 = ident1

	ident2 = f_sym3.SaveHook(ident1)

	invocation_sym3.Results.Ident2 = ident2

	return
}

// SetSaveStub configures Repository.Save to always return the given values
func (f_sym4 *FakeRepository) SetSaveStub(ident2 error) {
	f_sym4.SaveHook = func(*User) error {
		return ident2
	}
}

// SetSaveInvocation configures Repository.Save to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeRepository) SetSaveInvocation(calls_sym5 []*RepositorySaveInvocation, fallback_sym5 func() error) {
	f_sym5.SaveHook = func(ident1 *User) (ident2 error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Ident1, ident1) {
				ident2 = call_sym5.Results.Ident2

				return
			}
		}

		return fallback_sym5()
	}
}

// SaveCalled returns true if FakeRepository.Save was called
func (f *FakeRepository) SaveCalled() bool {
	return len(f.SaveCalls) != 0
}

// AssertSaveCalled calls t.Error if FakeRepository.Save was not called
func (f *FakeRepository) AssertSaveCalled(t RepositoryTestingT) {
	t.Helper()
	if len(f.SaveCalls) == 0 {
		t.Error("FakeRepository.Save not called, expected at least one")
	}
}

// SaveNotCalled returns true if FakeRepository.Save was not called
func (f *FakeRepository) SaveNotCalled() bool {
	return len(f.SaveCalls) == 0
}

// AssertSaveNotCalled calls t.Error if FakeRepository.Save was called
func (f *FakeRepository) AssertSaveNotCalled(t RepositoryTestingT) {
	t.Helper()
	if len(f.SaveCalls) != 0 {
		t.Error("FakeRepository.Save called, expected none")
	}
}

// SaveCalledOnce returns true if FakeRepository.Save was called exactly once
func (f *FakeRepository) SaveCalledOnce() bool {
	return len(f.SaveCalls) == 1
}

// AssertSaveCalledOnce calls t.Error if FakeRepository.Save was not called exactly once
func (f *FakeRepository) AssertSaveCalledOnce(t RepositoryTestingT) {
	t.Helper()
	if len(f.SaveCalls) != 1 {
		t.Errorf("FakeRepository.Save called %d times, expected 1", len(f.SaveCalls))
	}
}

// SaveCalledN returns true if FakeRepository.Save was called at least n times
func (f *FakeRepository) SaveCalledN(n int) bool {
	return len(f.SaveCalls) >= n
}

// AssertSaveCalledN calls t.Error if FakeRepository.Save was called less than n times
func (f *FakeRepository) AssertSaveCalledN(t RepositoryTestingT, n int) {
	t.Helper()
	if len(f.SaveCalls) < n {
		t.Errorf("FakeRepository.Save called %d times, expected >= %d", len(f.SaveCalls), n)
	}
}

// SaveCalledWith returns true if FakeRepository.Save was called with the given values
func (f_sym6 *FakeRepository) SaveCalledWith(ident1 *User) bool {
	for _, call_sym6 := range f_sym6.SaveCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertSaveCalledWith calls t.Error if FakeRepository.Save was not called with the given values
func (f_sym7 *FakeRepository) AssertSaveCalledWith(t RepositoryTestingT, ident1 *User) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.SaveCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Ident1, ident1) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeRepository.Save not called with expected parameters")
	}
}

// SaveCalledOnceWith returns true if FakeRepository.Save was called exactly once with the given values
func (f_sym8 *FakeRepository) SaveCalledOnceWith(ident1 *User) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.SaveCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Ident1, ident1) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertSaveCalledOnceWith calls t.Error if FakeRepository.Save was not called exactly once with the given values
func (f_sym9 *FakeRepository) AssertSaveCalledOnceWith(t RepositoryTestingT, ident1 *User) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.SaveCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Ident1, ident1) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeRepository.Save called %d times with expected parameters, expected one", count_sym9)
	}
}

// SaveResultsForCall returns the result values for the first call to FakeRepository.Save with the given values
func (f_sym10 *FakeRepository) SaveResultsForCall(ident1 *User) (ident2 error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.SaveCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Ident1, ident1) {
			ident2 = call_sym10.Results.Ident2
			found_sym10 = true
			break
		}
	}

	return
}

func (f_sym11 *FakeRepository) Get(ident1 string) (ident2 *User, ident3 error) {
	if f_sym11.GetHook == nil {
		panic("Repository.Get() called but FakeRepository.GetHook is nil")
	}

	invocation_sym11 := new(RepositoryGetInvocation)
	f_sym11.GetCalls = append(f_sym11.GetCalls, invocation_sym11)

	invocation_sym11.Parameters.Ident1 = ident1

	ident2, ident3 = f_sym11.GetHook(ident1)

	invocation_sym11.Results.Ident2 = ident2
	invocation_sym11.Results.Ident3 = ident3

	return
}

// SetGetStub configures Repository.Get to always return the given values
func (f_sym12 *FakeRepository) SetGetStub(ident2 *User, ident3 error) {
	f_sym12.GetHook = func(string) (*User, error) {
		return ident2, ident3
	}
}

// SetGetInvocation configures Repository.Get to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym13 *FakeRepository) SetGetInvocation(calls_sym13 []*RepositoryGetInvocation, fallback_sym13 func() (*User, error)) {
	f_sym13.GetHook = func(ident1 string) (ident2 *User, ident3 error) {
		for _, call_sym13 := range calls_sym13 {
			if reflect.DeepEqual(call_sym13.Parameters.Ident1, ident1) {
				ident2 = call_sym13.Results.Ident2
				ident3 = call_sym13.Results.Ident3

				return
			}
		}

		return fallback_sym13()
	}
}

// GetCalled returns true if FakeRepository.Get was called
func (f *FakeRepository) GetCalled() bool {
	return len(f.GetCalls) != 0
}

// AssertGetCalled calls t.Error if FakeRepository.Get was not called
func (f *FakeRepository) AssertGetCalled(t RepositoryTestingT) {
	t.Helper()
	if len(f.GetCalls) == 0 {
		t.Error("FakeRepository.Get not called, expected at least one")
	}
}

// GetNotCalled returns true if FakeRepository.Get was not called
func (f *FakeRepository) GetNotCalled() bool {
	return len(f.GetCalls) == 0
}

// AssertGetNotCalled calls t.Error if FakeRepository.Get was called
func (f *FakeRepository) AssertGetNotCalled(t RepositoryTestingT) {
	t.Helper()
	if len(f.GetCalls) != 0 {
		t.Error("FakeRepository.Get called, expected none")
	}
}

// GetCalledOnce returns true if FakeRepository.Get was called exactly once
func (f *FakeRepository) GetCalledOnce() bool {
	return len(f.GetCalls) == 1
}

// AssertGetCalledOnce calls t.Error if FakeRepository.Get was not called exactly once
func (f *FakeRepository) AssertGetCalledOnce(t RepositoryTestingT) {
	t.Helper()
	if len(f.GetCalls) != 1 {
		t.Errorf("FakeRepository.Get called %d times, expected 1", len(f.GetCalls))
	}
}

// GetCalledN returns true if FakeRepository.Get was called at least n times
func (f *FakeRepository) GetCalledN(n int) bool {
	return len(f.GetCalls) >= n
}

// AssertGetCalledN calls t.Error if FakeRepository.Get was called less than n times
func (f *FakeRepository) AssertGetCalledN(t RepositoryTestingT, n int) {
	t.Helper()
	if len(f.GetCalls) < n {
		t.Errorf("FakeRepository.Get called %d times, expected >= %d", len(f.GetCalls), n)
	}
}

// GetCalledWith returns true if FakeRepository.Get was called with the given values
func (f_sym14 *FakeRepository) GetCalledWith(ident1 string) bool {
	for _, call_sym14 := range f_sym14.GetCalls {
		if reflect.DeepEqual(call_sym14.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertGetCalledWith calls t.Error if FakeRepository.Get was not called with the given values
func (f_sym15 *FakeRepository) AssertGetCalledWith(t RepositoryTestingT, ident1 string) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.GetCalls {
		if reflect.DeepEqual(call_sym15.Parameters.Ident1, ident1) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("FakeRepository.Get not called with expected parameters")
	}
}

// GetCalledOnceWith returns true if FakeRepository.Get was called exactly once with the given values
func (f_sym16 *FakeRepository) GetCalledOnceWith(ident1 string) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.GetCalls {
		if reflect.DeepEqual(call_sym16.Parameters.Ident1, ident1) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertGetCalledOnceWith calls t.Error if FakeRepository.Get was not called exactly once with the given values
func (f_sym17 *FakeRepository) AssertGetCalledOnceWith(t RepositoryTestingT, ident1 string) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.GetCalls {
		if reflect.DeepEqual(call_sym17.Parameters.Ident1, ident1) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("FakeRepository.Get called %d times with expected parameters, expected one", count_sym17)
	}
}

// GetResultsForCall returns the result values for the first call to FakeRepository.Get with the given values
func (f_sym18 *FakeRepository) GetResultsForCall(ident1 string) (ident2 *User, ident3 error, found_sym18 bool) {
	for _, call_sym18 := range f_sym18.GetCalls {
		if reflect.DeepEqual(call_sym18.Parameters.Ident1, ident1) {
			ident2 = call_sym18.Results.Ident2
			ident3 = call_sym18.Results.Ident3
			found_sym18 = true
			break
		}
	}

	return
}
