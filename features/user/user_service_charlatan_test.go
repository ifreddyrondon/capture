// generated by "charlatan -output=user_service_charlatan_test.go Service".  DO NOT EDIT.

package user

import "reflect"

import kallax "gopkg.in/src-d/go-kallax.v1"

// ServiceGetByEmailInvocation represents a single call of FakeService.GetByEmail
type ServiceGetByEmailInvocation struct {
	Parameters struct {
		Ident1 string
	}
	Results struct {
		Ident2 *User
		Ident3 error
	}
}

// NewServiceGetByEmailInvocation creates a new instance of ServiceGetByEmailInvocation
func NewServiceGetByEmailInvocation(ident1 string, ident2 *User, ident3 error) *ServiceGetByEmailInvocation {
	invocation := new(ServiceGetByEmailInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return invocation
}

// ServiceGetByIDInvocation represents a single call of FakeService.GetByID
type ServiceGetByIDInvocation struct {
	Parameters struct {
		Ident1 kallax.ULID
	}
	Results struct {
		Ident2 *User
		Ident3 error
	}
}

// NewServiceGetByIDInvocation creates a new instance of ServiceGetByIDInvocation
func NewServiceGetByIDInvocation(ident1 kallax.ULID, ident2 *User, ident3 error) *ServiceGetByIDInvocation {
	invocation := new(ServiceGetByIDInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2
	invocation.Results.Ident3 = ident3

	return invocation
}

// ServiceSaveInvocation represents a single call of FakeService.Save
type ServiceSaveInvocation struct {
	Parameters struct {
		Ident1 *User
	}
	Results struct {
		Ident2 error
	}
}

// NewServiceSaveInvocation creates a new instance of ServiceSaveInvocation
func NewServiceSaveInvocation(ident1 *User, ident2 error) *ServiceSaveInvocation {
	invocation := new(ServiceSaveInvocation)

	invocation.Parameters.Ident1 = ident1

	invocation.Results.Ident2 = ident2

	return invocation
}

// ServiceTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type ServiceTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeService is a mock implementation of Service for testing.
Use it in your tests as in this example:

	package example

	func TestWithService(t *testing.T) {
		f := &user.FakeService{
			GetByEmailHook: func(ident1 string) (ident2 *User, ident3 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeGetByEmail ...
		f.AssertGetByEmailCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeGetByEmail.
*/
type FakeService struct {
	GetByEmailHook func(string) (*User, error)
	GetByIDHook    func(kallax.ULID) (*User, error)
	SaveHook       func(*User) error

	GetByEmailCalls []*ServiceGetByEmailInvocation
	GetByIDCalls    []*ServiceGetByIDInvocation
	SaveCalls       []*ServiceSaveInvocation
}

// NewFakeServiceDefaultPanic returns an instance of FakeService with all hooks configured to panic
func NewFakeServiceDefaultPanic() *FakeService {
	return &FakeService{
		GetByEmailHook: func(string) (ident2 *User, ident3 error) {
			panic("Unexpected call to Service.GetByEmail")
		},
		GetByIDHook: func(kallax.ULID) (ident2 *User, ident3 error) {
			panic("Unexpected call to Service.GetByID")
		},
		SaveHook: func(*User) (ident2 error) {
			panic("Unexpected call to Service.Save")
		},
	}
}

// NewFakeServiceDefaultFatal returns an instance of FakeService with all hooks configured to call t.Fatal
func NewFakeServiceDefaultFatal(t_sym1 ServiceTestingT) *FakeService {
	return &FakeService{
		GetByEmailHook: func(string) (ident2 *User, ident3 error) {
			t_sym1.Fatal("Unexpected call to Service.GetByEmail")
			return
		},
		GetByIDHook: func(kallax.ULID) (ident2 *User, ident3 error) {
			t_sym1.Fatal("Unexpected call to Service.GetByID")
			return
		},
		SaveHook: func(*User) (ident2 error) {
			t_sym1.Fatal("Unexpected call to Service.Save")
			return
		},
	}
}

// NewFakeServiceDefaultError returns an instance of FakeService with all hooks configured to call t.Error
func NewFakeServiceDefaultError(t_sym2 ServiceTestingT) *FakeService {
	return &FakeService{
		GetByEmailHook: func(string) (ident2 *User, ident3 error) {
			t_sym2.Error("Unexpected call to Service.GetByEmail")
			return
		},
		GetByIDHook: func(kallax.ULID) (ident2 *User, ident3 error) {
			t_sym2.Error("Unexpected call to Service.GetByID")
			return
		},
		SaveHook: func(*User) (ident2 error) {
			t_sym2.Error("Unexpected call to Service.Save")
			return
		},
	}
}

func (f *FakeService) Reset() {
	f.GetByEmailCalls = []*ServiceGetByEmailInvocation{}
	f.GetByIDCalls = []*ServiceGetByIDInvocation{}
	f.SaveCalls = []*ServiceSaveInvocation{}
}

func (f_sym3 *FakeService) GetByEmail(ident1 string) (ident2 *User, ident3 error) {
	if f_sym3.GetByEmailHook == nil {
		panic("Service.GetByEmail() called but FakeService.GetByEmailHook is nil")
	}

	invocation_sym3 := new(ServiceGetByEmailInvocation)
	f_sym3.GetByEmailCalls = append(f_sym3.GetByEmailCalls, invocation_sym3)

	invocation_sym3.Parameters.Ident1 = ident1

	ident2, ident3 = f_sym3.GetByEmailHook(ident1)

	invocation_sym3.Results.Ident2 = ident2
	invocation_sym3.Results.Ident3 = ident3

	return
}

// SetGetByEmailStub configures Service.GetByEmail to always return the given values
func (f_sym4 *FakeService) SetGetByEmailStub(ident2 *User, ident3 error) {
	f_sym4.GetByEmailHook = func(string) (*User, error) {
		return ident2, ident3
	}
}

// SetGetByEmailInvocation configures Service.GetByEmail to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeService) SetGetByEmailInvocation(calls_sym5 []*ServiceGetByEmailInvocation, fallback_sym5 func() (*User, error)) {
	f_sym5.GetByEmailHook = func(ident1 string) (ident2 *User, ident3 error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Ident1, ident1) {
				ident2 = call_sym5.Results.Ident2
				ident3 = call_sym5.Results.Ident3

				return
			}
		}

		return fallback_sym5()
	}
}

// GetByEmailCalled returns true if FakeService.GetByEmail was called
func (f *FakeService) GetByEmailCalled() bool {
	return len(f.GetByEmailCalls) != 0
}

// AssertGetByEmailCalled calls t.Error if FakeService.GetByEmail was not called
func (f *FakeService) AssertGetByEmailCalled(t ServiceTestingT) {
	t.Helper()
	if len(f.GetByEmailCalls) == 0 {
		t.Error("FakeService.GetByEmail not called, expected at least one")
	}
}

// GetByEmailNotCalled returns true if FakeService.GetByEmail was not called
func (f *FakeService) GetByEmailNotCalled() bool {
	return len(f.GetByEmailCalls) == 0
}

// AssertGetByEmailNotCalled calls t.Error if FakeService.GetByEmail was called
func (f *FakeService) AssertGetByEmailNotCalled(t ServiceTestingT) {
	t.Helper()
	if len(f.GetByEmailCalls) != 0 {
		t.Error("FakeService.GetByEmail called, expected none")
	}
}

// GetByEmailCalledOnce returns true if FakeService.GetByEmail was called exactly once
func (f *FakeService) GetByEmailCalledOnce() bool {
	return len(f.GetByEmailCalls) == 1
}

// AssertGetByEmailCalledOnce calls t.Error if FakeService.GetByEmail was not called exactly once
func (f *FakeService) AssertGetByEmailCalledOnce(t ServiceTestingT) {
	t.Helper()
	if len(f.GetByEmailCalls) != 1 {
		t.Errorf("FakeService.GetByEmail called %d times, expected 1", len(f.GetByEmailCalls))
	}
}

// GetByEmailCalledN returns true if FakeService.GetByEmail was called at least n times
func (f *FakeService) GetByEmailCalledN(n int) bool {
	return len(f.GetByEmailCalls) >= n
}

// AssertGetByEmailCalledN calls t.Error if FakeService.GetByEmail was called less than n times
func (f *FakeService) AssertGetByEmailCalledN(t ServiceTestingT, n int) {
	t.Helper()
	if len(f.GetByEmailCalls) < n {
		t.Errorf("FakeService.GetByEmail called %d times, expected >= %d", len(f.GetByEmailCalls), n)
	}
}

// GetByEmailCalledWith returns true if FakeService.GetByEmail was called with the given values
func (f_sym6 *FakeService) GetByEmailCalledWith(ident1 string) bool {
	for _, call_sym6 := range f_sym6.GetByEmailCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertGetByEmailCalledWith calls t.Error if FakeService.GetByEmail was not called with the given values
func (f_sym7 *FakeService) AssertGetByEmailCalledWith(t ServiceTestingT, ident1 string) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.GetByEmailCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Ident1, ident1) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeService.GetByEmail not called with expected parameters")
	}
}

// GetByEmailCalledOnceWith returns true if FakeService.GetByEmail was called exactly once with the given values
func (f_sym8 *FakeService) GetByEmailCalledOnceWith(ident1 string) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.GetByEmailCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Ident1, ident1) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertGetByEmailCalledOnceWith calls t.Error if FakeService.GetByEmail was not called exactly once with the given values
func (f_sym9 *FakeService) AssertGetByEmailCalledOnceWith(t ServiceTestingT, ident1 string) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.GetByEmailCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Ident1, ident1) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeService.GetByEmail called %d times with expected parameters, expected one", count_sym9)
	}
}

// GetByEmailResultsForCall returns the result values for the first call to FakeService.GetByEmail with the given values
func (f_sym10 *FakeService) GetByEmailResultsForCall(ident1 string) (ident2 *User, ident3 error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.GetByEmailCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Ident1, ident1) {
			ident2 = call_sym10.Results.Ident2
			ident3 = call_sym10.Results.Ident3
			found_sym10 = true
			break
		}
	}

	return
}

func (f_sym11 *FakeService) GetByID(ident1 kallax.ULID) (ident2 *User, ident3 error) {
	if f_sym11.GetByIDHook == nil {
		panic("Service.GetByID() called but FakeService.GetByIDHook is nil")
	}

	invocation_sym11 := new(ServiceGetByIDInvocation)
	f_sym11.GetByIDCalls = append(f_sym11.GetByIDCalls, invocation_sym11)

	invocation_sym11.Parameters.Ident1 = ident1

	ident2, ident3 = f_sym11.GetByIDHook(ident1)

	invocation_sym11.Results.Ident2 = ident2
	invocation_sym11.Results.Ident3 = ident3

	return
}

// SetGetByIDStub configures Service.GetByID to always return the given values
func (f_sym12 *FakeService) SetGetByIDStub(ident2 *User, ident3 error) {
	f_sym12.GetByIDHook = func(kallax.ULID) (*User, error) {
		return ident2, ident3
	}
}

// SetGetByIDInvocation configures Service.GetByID to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym13 *FakeService) SetGetByIDInvocation(calls_sym13 []*ServiceGetByIDInvocation, fallback_sym13 func() (*User, error)) {
	f_sym13.GetByIDHook = func(ident1 kallax.ULID) (ident2 *User, ident3 error) {
		for _, call_sym13 := range calls_sym13 {
			if reflect.DeepEqual(call_sym13.Parameters.Ident1, ident1) {
				ident2 = call_sym13.Results.Ident2
				ident3 = call_sym13.Results.Ident3

				return
			}
		}

		return fallback_sym13()
	}
}

// GetByIDCalled returns true if FakeService.GetByID was called
func (f *FakeService) GetByIDCalled() bool {
	return len(f.GetByIDCalls) != 0
}

// AssertGetByIDCalled calls t.Error if FakeService.GetByID was not called
func (f *FakeService) AssertGetByIDCalled(t ServiceTestingT) {
	t.Helper()
	if len(f.GetByIDCalls) == 0 {
		t.Error("FakeService.GetByID not called, expected at least one")
	}
}

// GetByIDNotCalled returns true if FakeService.GetByID was not called
func (f *FakeService) GetByIDNotCalled() bool {
	return len(f.GetByIDCalls) == 0
}

// AssertGetByIDNotCalled calls t.Error if FakeService.GetByID was called
func (f *FakeService) AssertGetByIDNotCalled(t ServiceTestingT) {
	t.Helper()
	if len(f.GetByIDCalls) != 0 {
		t.Error("FakeService.GetByID called, expected none")
	}
}

// GetByIDCalledOnce returns true if FakeService.GetByID was called exactly once
func (f *FakeService) GetByIDCalledOnce() bool {
	return len(f.GetByIDCalls) == 1
}

// AssertGetByIDCalledOnce calls t.Error if FakeService.GetByID was not called exactly once
func (f *FakeService) AssertGetByIDCalledOnce(t ServiceTestingT) {
	t.Helper()
	if len(f.GetByIDCalls) != 1 {
		t.Errorf("FakeService.GetByID called %d times, expected 1", len(f.GetByIDCalls))
	}
}

// GetByIDCalledN returns true if FakeService.GetByID was called at least n times
func (f *FakeService) GetByIDCalledN(n int) bool {
	return len(f.GetByIDCalls) >= n
}

// AssertGetByIDCalledN calls t.Error if FakeService.GetByID was called less than n times
func (f *FakeService) AssertGetByIDCalledN(t ServiceTestingT, n int) {
	t.Helper()
	if len(f.GetByIDCalls) < n {
		t.Errorf("FakeService.GetByID called %d times, expected >= %d", len(f.GetByIDCalls), n)
	}
}

// GetByIDCalledWith returns true if FakeService.GetByID was called with the given values
func (f_sym14 *FakeService) GetByIDCalledWith(ident1 kallax.ULID) bool {
	for _, call_sym14 := range f_sym14.GetByIDCalls {
		if reflect.DeepEqual(call_sym14.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertGetByIDCalledWith calls t.Error if FakeService.GetByID was not called with the given values
func (f_sym15 *FakeService) AssertGetByIDCalledWith(t ServiceTestingT, ident1 kallax.ULID) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.GetByIDCalls {
		if reflect.DeepEqual(call_sym15.Parameters.Ident1, ident1) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("FakeService.GetByID not called with expected parameters")
	}
}

// GetByIDCalledOnceWith returns true if FakeService.GetByID was called exactly once with the given values
func (f_sym16 *FakeService) GetByIDCalledOnceWith(ident1 kallax.ULID) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.GetByIDCalls {
		if reflect.DeepEqual(call_sym16.Parameters.Ident1, ident1) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertGetByIDCalledOnceWith calls t.Error if FakeService.GetByID was not called exactly once with the given values
func (f_sym17 *FakeService) AssertGetByIDCalledOnceWith(t ServiceTestingT, ident1 kallax.ULID) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.GetByIDCalls {
		if reflect.DeepEqual(call_sym17.Parameters.Ident1, ident1) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("FakeService.GetByID called %d times with expected parameters, expected one", count_sym17)
	}
}

// GetByIDResultsForCall returns the result values for the first call to FakeService.GetByID with the given values
func (f_sym18 *FakeService) GetByIDResultsForCall(ident1 kallax.ULID) (ident2 *User, ident3 error, found_sym18 bool) {
	for _, call_sym18 := range f_sym18.GetByIDCalls {
		if reflect.DeepEqual(call_sym18.Parameters.Ident1, ident1) {
			ident2 = call_sym18.Results.Ident2
			ident3 = call_sym18.Results.Ident3
			found_sym18 = true
			break
		}
	}

	return
}

func (f_sym19 *FakeService) Save(ident1 *User) (ident2 error) {
	if f_sym19.SaveHook == nil {
		panic("Service.Save() called but FakeService.SaveHook is nil")
	}

	invocation_sym19 := new(ServiceSaveInvocation)
	f_sym19.SaveCalls = append(f_sym19.SaveCalls, invocation_sym19)

	invocation_sym19.Parameters.Ident1 = ident1

	ident2 = f_sym19.SaveHook(ident1)

	invocation_sym19.Results.Ident2 = ident2

	return
}

// SetSaveStub configures Service.Save to always return the given values
func (f_sym20 *FakeService) SetSaveStub(ident2 error) {
	f_sym20.SaveHook = func(*User) error {
		return ident2
	}
}

// SetSaveInvocation configures Service.Save to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym21 *FakeService) SetSaveInvocation(calls_sym21 []*ServiceSaveInvocation, fallback_sym21 func() error) {
	f_sym21.SaveHook = func(ident1 *User) (ident2 error) {
		for _, call_sym21 := range calls_sym21 {
			if reflect.DeepEqual(call_sym21.Parameters.Ident1, ident1) {
				ident2 = call_sym21.Results.Ident2

				return
			}
		}

		return fallback_sym21()
	}
}

// SaveCalled returns true if FakeService.Save was called
func (f *FakeService) SaveCalled() bool {
	return len(f.SaveCalls) != 0
}

// AssertSaveCalled calls t.Error if FakeService.Save was not called
func (f *FakeService) AssertSaveCalled(t ServiceTestingT) {
	t.Helper()
	if len(f.SaveCalls) == 0 {
		t.Error("FakeService.Save not called, expected at least one")
	}
}

// SaveNotCalled returns true if FakeService.Save was not called
func (f *FakeService) SaveNotCalled() bool {
	return len(f.SaveCalls) == 0
}

// AssertSaveNotCalled calls t.Error if FakeService.Save was called
func (f *FakeService) AssertSaveNotCalled(t ServiceTestingT) {
	t.Helper()
	if len(f.SaveCalls) != 0 {
		t.Error("FakeService.Save called, expected none")
	}
}

// SaveCalledOnce returns true if FakeService.Save was called exactly once
func (f *FakeService) SaveCalledOnce() bool {
	return len(f.SaveCalls) == 1
}

// AssertSaveCalledOnce calls t.Error if FakeService.Save was not called exactly once
func (f *FakeService) AssertSaveCalledOnce(t ServiceTestingT) {
	t.Helper()
	if len(f.SaveCalls) != 1 {
		t.Errorf("FakeService.Save called %d times, expected 1", len(f.SaveCalls))
	}
}

// SaveCalledN returns true if FakeService.Save was called at least n times
func (f *FakeService) SaveCalledN(n int) bool {
	return len(f.SaveCalls) >= n
}

// AssertSaveCalledN calls t.Error if FakeService.Save was called less than n times
func (f *FakeService) AssertSaveCalledN(t ServiceTestingT, n int) {
	t.Helper()
	if len(f.SaveCalls) < n {
		t.Errorf("FakeService.Save called %d times, expected >= %d", len(f.SaveCalls), n)
	}
}

// SaveCalledWith returns true if FakeService.Save was called with the given values
func (f_sym22 *FakeService) SaveCalledWith(ident1 *User) bool {
	for _, call_sym22 := range f_sym22.SaveCalls {
		if reflect.DeepEqual(call_sym22.Parameters.Ident1, ident1) {
			return true
		}
	}

	return false
}

// AssertSaveCalledWith calls t.Error if FakeService.Save was not called with the given values
func (f_sym23 *FakeService) AssertSaveCalledWith(t ServiceTestingT, ident1 *User) {
	t.Helper()
	var found_sym23 bool
	for _, call_sym23 := range f_sym23.SaveCalls {
		if reflect.DeepEqual(call_sym23.Parameters.Ident1, ident1) {
			found_sym23 = true
			break
		}
	}

	if !found_sym23 {
		t.Error("FakeService.Save not called with expected parameters")
	}
}

// SaveCalledOnceWith returns true if FakeService.Save was called exactly once with the given values
func (f_sym24 *FakeService) SaveCalledOnceWith(ident1 *User) bool {
	var count_sym24 int
	for _, call_sym24 := range f_sym24.SaveCalls {
		if reflect.DeepEqual(call_sym24.Parameters.Ident1, ident1) {
			count_sym24++
		}
	}

	return count_sym24 == 1
}

// AssertSaveCalledOnceWith calls t.Error if FakeService.Save was not called exactly once with the given values
func (f_sym25 *FakeService) AssertSaveCalledOnceWith(t ServiceTestingT, ident1 *User) {
	t.Helper()
	var count_sym25 int
	for _, call_sym25 := range f_sym25.SaveCalls {
		if reflect.DeepEqual(call_sym25.Parameters.Ident1, ident1) {
			count_sym25++
		}
	}

	if count_sym25 != 1 {
		t.Errorf("FakeService.Save called %d times with expected parameters, expected one", count_sym25)
	}
}

// SaveResultsForCall returns the result values for the first call to FakeService.Save with the given values
func (f_sym26 *FakeService) SaveResultsForCall(ident1 *User) (ident2 error, found_sym26 bool) {
	for _, call_sym26 := range f_sym26.SaveCalls {
		if reflect.DeepEqual(call_sym26.Parameters.Ident1, ident1) {
			ident2 = call_sym26.Results.Ident2
			found_sym26 = true
			break
		}
	}

	return
}
